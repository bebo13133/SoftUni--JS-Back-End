/**
 * @license
 * MIT License
 *
 * Copyright (c) 2018 Goffert van Gool
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

const marker = Math.random()
  .toString(36)
  .slice(2)
  .padStart(10, '0');
const attributeMarker = `font-family:${marker}`;
const IEStyleMarker = `font-family: ${marker};`;
const commentMarker = `comment-${marker}`;
const failMarker = `node-${marker}`;
const nodeMarker = `${failMarker}" ${failMarker} `;

const isSerializable = value => typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
const isIterable = nonPrimitive => Array.isArray(nonPrimitive) || nonPrimitive[Symbol.iterator];

// A flag that signals that no render should happen
const noChange = {};

// A node type for empty parts
const emptyNode = {};
// A node type for parts that contain an iterable
const iterableNode = {};

class NodePart {
  // node OR parent _must_ be defined
  // If a node is defined, this NodePart represents the position of that node in the tree
  // If a only a parent is defined, this NodePart represents the content of the parent
  constructor({ node, parent, before, after }) {
    this.node = node || emptyNode;
    this.value = noChange;

    this.parentNode = parent || (node && node.parentNode);
    this.beforeNode = before || (node && node.previousSibling);
    this.afterNode = after || (node && node.nextSibling);
  }

  render(value) {
    if (value === noChange) {
      return;
    }
    if (value == null) {
      this.clear();
    } else if (isSerializable(value)) {
      this._renderText(value);
    } else if (value instanceof TemplateResult) {
      this._renderTemplateResult(value);
    } else if (isIterable(value)) {
      this._renderIterable(value);
    } else if (value instanceof Node) {
      this._renderNode(value);
    } else if (value.then !== undefined) {
      this._renderPromise(value);
    } else {
      value = String(value);
      this._renderText(value);
    }
    this.value = value;
  }

  /**
   * Render a serializable value in this part
   *
   * Strings, Numbers, and Booleans are serializable
   * Serializable values are rendered as textContent of a TextNode
   */
  _renderText(serializable) {
    // If the text is not equal to the previously rendered value
    if (this.value !== serializable) {
      // If the node is a TextNode, replace the content of that node
      // Otherwise, create a new TextNode with the primitive value as content
      if (this.node.nodeType === 3) {
        this.node.textContent = serializable;
      } else {
        this._renderNode(document.createTextNode(serializable));
      }
    }
  }

  /**
   * Render a TemplateResult in this part
   *
   * Checks if this template has already been rendered in this part before.
   * If so, re-use that TemplateInstance
   * If not, create a new TemplateInstance
   */
  _renderTemplateResult(templateResult) {
    this.templateInstances = this.templateInstances || new Map();
    let instance = this.templateInstances.get(templateResult.template);
    if (!instance) {
      instance = new TemplateInstance(templateResult.template, this.parentNode, this.beforeNode, this.afterNode);
      this.templateInstances.set(templateResult.template, instance);
    }
    if (this.node !== instance.fragment) {
      this.clear();
      this.parentNode.insertBefore(instance.fragment, this.afterNode);
      this.node = instance.fragment;
    }
    instance.render(templateResult.values);
  }

  /**
   * Render an iterable in this part
   *
   * Creates a part for each item in the iterable
   * Render each iterable value in a part
   */
  _renderIterable(iterable) {
    if (this.node !== iterableNode) {
      this.clear();
      this.node = iterableNode;
      if (!this.iterableParts) {
        this.iterableParts = [];
      } else {
        this.iterableParts.length = 0;
      }
    }

    // if (this.iterableParts.length < iterable.length) {
    //   let after;
    //   let before = this.afterNode ? this.afterNode.previousSibling : this.parentNode.lastChild;
    //   const parent = this.parentNode;
    //   do {
    //     after = document.createTextNode('');
    //     this.parentNode.insertBefore(after, this.afterNode);
    //     this.iterableParts.push(new NodePart({ before, after, parent }));
    //     before = after;
    //   } while (this.iterableParts.length < iterable.length);
    // } else if (this.iterableParts.length > iterable.length) {
    //   const nodeToRemove = this.iterableParts[iterable.length].beforeNode.nextSibling;
    //   moveNodes(this.parentNode, nodeToRemove, this.afterNode);
    //   this.iterableParts.length = iterable.length;
    // }

    let index = 0;
    let before = this.afterNode ? this.afterNode.previousSibling : this.parentNode.lastChild;
    let after;
    const parent = this.parentNode;
    for (const value of iterable) {
      let part = this.iterableParts[index];
      if (part === undefined) {
        after = document.createTextNode('');
        this.parentNode.insertBefore(after, this.afterNode);
        part = new NodePart({ before, after, parent });
        this.iterableParts.push(part);
        before = after;
      }
      part.render(value);
      index++;
    }
    if (index === 0) {
      moveNodes(this.parentNode, this.beforeNode, this.afterNode);
    } else if (index < this.iterableParts.length) {
      const lastPart = this.iterableParts[index - 1];
      moveNodes(this.parentNode, lastPart.afterNode, this.afterNode);
    }
    this.iterableParts.length = index;
  }

  /**
   * Render a DOM node in this part
   */
  _renderNode(node) {
    // If we are not already rendering this node
    if (this.node !== node) {
      this.clear();
      this.parentNode.insertBefore(node, this.afterNode);
      this.node = node;
    }
  }

  /**
   * Render the result of a promise in this part
   */
  _renderPromise(promise) {
    // If the promise is not the last value or promise
    if (this.value !== promise && this.promise !== promise) {
      this.clear();
      this.promise = promise;
      this.value = promise;
      // When the promise resolves, render the result of that promise
      promise.then(value => {
        // Render the promise result only if the last rendered value was the promise
        if (this.value === promise) {
          this.render(value);
        }
      });
    }
  }

  /**
   * Clear out the content of this NodePart
   *
   * If the current content is part of a DocumentFragment (it is the result of a TemplateResult or an Array)
   * The current content is moved back into that fragment to be used again if the same fragment is rendered
   * Otherwise, the current content is removed from the DOM permanently
   */
  clear() {
    moveNodes(this.parentNode, this.beforeNode, this.afterNode, this.node);
    this.node = emptyNode;
  }
}

const moveNodes = (parent, before, after, target) => {
  let nodeToRemove;
  if (before == undefined) {
    nodeToRemove = parent.firstChild;
  } else {
    nodeToRemove = before && before.nextSibling;
  }
  if (nodeToRemove !== null) {
    nodeToRemove = nodeToRemove || parent.firstChild;
    let remove;
    let nextNode;
    if (target instanceof DocumentFragment) {
      remove = () => target.appendChild(nodeToRemove);
    } else {
      remove = () => parent.removeChild(nodeToRemove);
    }

    while (nodeToRemove != after) {
      nextNode = nodeToRemove.nextSibling;
      remove();
      nodeToRemove = nextNode;
    }
  }
};

// The node in the CommentPart constructor must be a CommentNode
class CommentPart {
  constructor({ node }) {
    this.node = node;
  }

  render(value) {
    this.node.textContent = value;
  }
}

class AttributePart {
  constructor({ node, attribute }) {
    this.node = node;
    switch (attribute[0]) {
      case '.':
        this.render = this._renderProperty;
      case '?':
        this.render = this.render || this._renderBoolean;
      case '@':
        this.render = this.render || this._renderEvent;
        this.node.removeAttribute(attribute);
        this.name = attribute.slice(1);
        break;
      default:
        this.render = this._renderAttribute;
        this.name = attribute;
    }
  }

  _renderProperty(value) {
    this.node[this.name] = value;
  }

  _renderBoolean(boolean) {
    if (this.value !== !!boolean) {
      boolean ? this.node.setAttribute(this.name, '') : this.node.removeAttribute(this.name);
      this.value = boolean;
    }
  }

  _renderEvent(listener) {
    if (this.value !== listener) {
      this.node.removeEventListener(this.name, this.value);
      this.node.addEventListener(this.name, listener);
      this.value = listener;
    }
  }

  _renderAttribute(string) {
    if (string !== this.value) {
      this.node.setAttribute(this.name, string);
      this.value = string;
    }
  }
}

const lastAttributeNameRegex = /[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=$/;
const filter = [].filter;

const findParts = (strings, template) => {
  let parts = [];

  // Recursive depth-first tree traversal that finds nodes in the subtree of `node` that are parts
  // The path is an array of incides of childNodes to get to this node
  const recursiveSearch = (node, path) => {
    // If the node is a CommentNode, check if it is a marker for a CommentPart or NodePart
    if (node.nodeType === 8) {
      if (node.nodeValue === commentMarker) {
        parts.push({ type: CommentPart, path });
      } else if (node.nodeValue === nodeMarker) {
        parts.push({ type: NodePart, path });
      }
      // If it is not a marker for a Part, it is a regular comment
    } else {
      // If the node is an ElementNode, it may contain AttributeParts
      if (node.nodeType === 1) {
        // If the node has the failMarker, the context was incorrectly recognised as a Node context
        // This happens when an attribute literal contains the '>' character
        // There is no way to fix this, so throw an error to alert the developer to fix it
        if (node.hasAttribute(failMarker)) {
          throw new Error("The '>' character is not allowed in attribute literals. Replace with '&gt;'");
        }
        // If the node has any AttributeParts, it will have the attributeMarker attribute set
        if (node.hasAttribute(attributeMarker)) {
          node.removeAttribute(attributeMarker);

          // Find the number of dynamic attributes by checking all attribute values against the attributeMarker
          let dynamicAttributes = filter.call(node.attributes, attribute => attribute.value === attributeMarker).length;

          // If the node has the 'style' attribute, test against IEStyleMarker to check if the attribute is dynamic
          if (node.getAttribute('style') === IEStyleMarker) {
            dynamicAttributes += 1;
          }

          for (let i = 0; i < dynamicAttributes; i++) {
            // Find the name of this AttributePart using the lastAttributeNameRegex on the string before this part
            const attribute = lastAttributeNameRegex.exec(strings[parts.length])[1];
            parts.push({ type: AttributePart, path, attribute });
          }
        }
      }

      // Recursively search all children of this node
      const children = node.childNodes;
      const length = children.length;
      for (let i = 0; i < length; i++) {
        recursiveSearch(children[i], path.concat([i]));
      }
    }
  };

  // Recursively search the content of the template for parts
  recursiveSearch(template.content, []);

  // If we found less parts than we should, something went wrong
  // Most likely a double attribute assignment was dropped by the HTML parser
  // Throw an error and warn the developer
  if (parts.length < strings.length - 1) {
    throw new Error("Double attribute assignments are not allowed: '<div a=${0} a=${0}>'");
  }
  return parts;
};

// The second marker is to add a boolean attribute to the element
// This is to easily test if a node has dynamic attributes by checking against that attribute
const attributeMarkerTag = `${attributeMarker} ${attributeMarker}`;

// The space at the end is necessary, to avoid accidentally closing comments with `<!-->`
const commentMarkerTag = `--><!--${commentMarker}--><!-- `;

// The extra content at the end is to add a flag to an element when
// a nodeMarkerTag is inserted as an attribute due to an attribute containing `>`
const nodeMarkerTag = `<!--${nodeMarker}-->`;

const attributeContext = Symbol('attributeContext');
const commentContext = Symbol('commentContext');
const nodeContext = Symbol('nodeContext');
const unchangedContext = Symbol('unchangedContext');

const contextMap = new Map();
contextMap.set(attributeContext, attributeMarkerTag);
contextMap.set(commentContext, commentMarkerTag);
contextMap.set(nodeContext, nodeMarkerTag);

const parseContext = string => {
  const openComment = string.lastIndexOf('<!--');
  const closeComment = string.indexOf('-->', openComment + 1);
  const commentClosed = closeComment > -1;
  let type;
  if (openComment > -1 && !commentClosed) {
    type = commentContext;
  } else {
    const closeTag = string.lastIndexOf('>');
    const openTag = string.indexOf('<', closeTag + 1);
    if (openTag > -1) {
      type = attributeContext;
    } else {
      if (closeTag > -1) {
        type = nodeContext;
      } else {
        type = unchangedContext;
      }
    }
  }
  return { commentClosed, type };
};

const parseTemplate = strings => {
  const html = [];
  const lastStringIndex = strings.length - 1;
  let currentContext = nodeContext;
  for (let i = 0; i < lastStringIndex; i++) {
    const string = strings[i];
    const context = parseContext(string);
    if ((currentContext !== commentContext || context.commentClosed) && context.type !== unchangedContext) {
      currentContext = context.type;
    }
    if (currentContext === attributeContext && string.slice(-1) !== '=') {
      throw new Error('Only bare attribute parts are allowed: `<div a=${0}>`');
    }
    html.push(string);
    html.push(contextMap.get(currentContext));
  }

  html.push(strings[lastStringIndex]);
  return html.join('');
};

const buildTemplate = strings => {
  const template = document.createElement('template');
  template.innerHTML = parseTemplate(strings);
  return template;
};

/**
 * A map that contains all the template literals we have seen before
 * It maps from a String array to a Template object
 *
 * @typedef {Map.<[String], Template>}
 */
const templateMap = new Map();

/**
 * Template holds the DocumentFragment that is to be used as a prototype for instances of this template
 * When a template is to be rendered in a new location, a clone will be made from this
 *
 * @prop {[String]} strings
 *   The unique string array that this template represents
 * @prop {[DocumentFragment]} element
 *   The DocumentFragment that can be cloned to make instances of this template
 * @prop {[Object]} parts
 *   The descriptions of the parts in this Template. Each part has a path which defines a unique location in the
 *   template DOM tree, a type which defines the part type, and an optional attribute which defines the name of
 *   the attribute this part represents.
 */
class Template {
  constructor(strings) {
    this.strings = strings;
    this.element = buildTemplate(strings);
    this.parts = findParts(strings, this.element);
  }
}

/**
 * TemplateResult holds the strings and values that result from a tagged template string literal.
 * TemplateResult can find and return a unique Template object that represents its tagged template string literal.
 */
class TemplateResult {
  constructor(strings, values) {
    this.strings = strings;
    this.values = values;
    this._template = undefined;
  }

  get template() {
    if (this._template) {
      return this._template;
    }
    let template = templateMap.get(this.strings);
    if (!template) {
      template = new Template(this.strings);
      templateMap.set(this.strings, template);
    }
    this._template = template;
    return template;
  }
}

/**
 * An instance of a template that can be rendered somewhere
 *
 * @prop {Template} template
 *   The unique Template object that this is an instance of
 * @prop {[DocumentFragment]} fragment
 *   The DocumentFragment that is a clone of the Template's prototype DocumentFragment
 * @prop {[AttributePart|CommentPart|NodePart|]} parts
 *   The parts that render into this template instance
 */
class TemplateInstance {
  constructor(template, parent, before, after) {
    this.template = template;
    this.fragment = template.element.content.cloneNode(true);

    // Create new Parts based on the part definitions set on the Template
    const parts = this.template.parts.map(part => {
      let node = this.fragment;
      part.path.forEach(nodeIndex => {
        node = node.childNodes[nodeIndex];
      });
      part.node = node;
      if (part.type === NodePart) {
        if (part.path.length === 1) {
          part.parent = parent;
          part.before = node.previousSibling || before;
          part.after = node.nextSibling || after;
        } else {
          part.parent = node.parentNode;
        }
      }
      return part;
    });
    this.parts = parts.map(part => new part.type(part));
  }

  /**
   * Render values into the parts of this TemplateInstance
   *
   * @param {[any]} values
   *   An array of values to render into the parts. There should be one value per part
   */
  render(values) {
    this.parts.map((part, index) => part.render(values[index]));
  }
}

/**
 * Tagging function to tag JavaScript template string literals as HTML
 *
 * @return {TemplateResult}
 *   The strings and values of the template string wrapped in a TemplateResult object
 */
const html = (strings, ...values) => {
  return new TemplateResult(strings, values);
};

/**
 * Render content into a target node
 *
 * @param {any} content
 *   Any content you wish to render. Usually a template string literal tagged with the `html` function
 * @param {Node} target
 *   An HTML Node that you wish to render the content into.
 *   The content will become the sole content of the target node.
 */
const render = (content, target) => {
  // Check if the target has a NodePart that represents its content
  let part = target.__nodePart;
  if (!part) {
    // If it does not, create a new NodePart
    part = new NodePart({ parent: target });
    target.__nodePart = part;
  }
  // Task the NodePart of this target to render the content
  part.render(content);
};

export { html, render, noChange };
//# sourceMappingURL=lite-html.js.map
