/**
 * @license
 * MIT License
 *
 * Copyright (c) 2018 Goffert van Gool
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global['lite-html'] = {})));
}(this, (function (exports) { 'use strict';

  var marker = Math.random().toString(36).slice(2).padStart(10, '0');
  var attributeMarker = 'font-family:' + marker;
  var IEStyleMarker = 'font-family: ' + marker + ';';
  var commentMarker = 'comment-' + marker;
  var failMarker = 'node-' + marker;
  var nodeMarker = failMarker + '" ' + failMarker + ' ';

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var isSerializable = function isSerializable(value) {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
  };
  var isIterable = function isIterable(nonPrimitive) {
    return Array.isArray(nonPrimitive) || nonPrimitive[Symbol.iterator];
  };

  // A flag that signals that no render should happen
  var noChange = {};

  // A node type for empty parts
  var emptyNode = {};
  // A node type for parts that contain an iterable
  var iterableNode = {};

  var NodePart = function () {
    // node OR parent _must_ be defined
    // If a node is defined, this NodePart represents the position of that node in the tree
    // If a only a parent is defined, this NodePart represents the content of the parent
    function NodePart(_ref) {
      var node = _ref.node,
          parent = _ref.parent,
          before = _ref.before,
          after = _ref.after;
      classCallCheck(this, NodePart);

      this.node = node || emptyNode;
      this.value = noChange;

      this.parentNode = parent || node && node.parentNode;
      this.beforeNode = before || node && node.previousSibling;
      this.afterNode = after || node && node.nextSibling;
    }

    createClass(NodePart, [{
      key: 'render',
      value: function render(value) {
        if (value === noChange) {
          return;
        }
        if (value == null) {
          this.clear();
        } else if (isSerializable(value)) {
          this._renderText(value);
        } else if (value instanceof TemplateResult) {
          this._renderTemplateResult(value);
        } else if (isIterable(value)) {
          this._renderIterable(value);
        } else if (value instanceof Node) {
          this._renderNode(value);
        } else if (value.then !== undefined) {
          this._renderPromise(value);
        } else {
          value = String(value);
          this._renderText(value);
        }
        this.value = value;
      }

      /**
       * Render a serializable value in this part
       *
       * Strings, Numbers, and Booleans are serializable
       * Serializable values are rendered as textContent of a TextNode
       */

    }, {
      key: '_renderText',
      value: function _renderText(serializable) {
        // If the text is not equal to the previously rendered value
        if (this.value !== serializable) {
          // If the node is a TextNode, replace the content of that node
          // Otherwise, create a new TextNode with the primitive value as content
          if (this.node.nodeType === 3) {
            this.node.textContent = serializable;
          } else {
            this._renderNode(document.createTextNode(serializable));
          }
        }
      }

      /**
       * Render a TemplateResult in this part
       *
       * Checks if this template has already been rendered in this part before.
       * If so, re-use that TemplateInstance
       * If not, create a new TemplateInstance
       */

    }, {
      key: '_renderTemplateResult',
      value: function _renderTemplateResult(templateResult) {
        this.templateInstances = this.templateInstances || new Map();
        var instance = this.templateInstances.get(templateResult.template);
        if (!instance) {
          instance = new TemplateInstance(templateResult.template, this.parentNode, this.beforeNode, this.afterNode);
          this.templateInstances.set(templateResult.template, instance);
        }
        if (this.node !== instance.fragment) {
          this.clear();
          this.parentNode.insertBefore(instance.fragment, this.afterNode);
          this.node = instance.fragment;
        }
        instance.render(templateResult.values);
      }

      /**
       * Render an iterable in this part
       *
       * Creates a part for each item in the iterable
       * Render each iterable value in a part
       */

    }, {
      key: '_renderIterable',
      value: function _renderIterable(iterable) {
        if (this.node !== iterableNode) {
          this.clear();
          this.node = iterableNode;
          if (!this.iterableParts) {
            this.iterableParts = [];
          } else {
            this.iterableParts.length = 0;
          }
        }

        // if (this.iterableParts.length < iterable.length) {
        //   let after;
        //   let before = this.afterNode ? this.afterNode.previousSibling : this.parentNode.lastChild;
        //   const parent = this.parentNode;
        //   do {
        //     after = document.createTextNode('');
        //     this.parentNode.insertBefore(after, this.afterNode);
        //     this.iterableParts.push(new NodePart({ before, after, parent }));
        //     before = after;
        //   } while (this.iterableParts.length < iterable.length);
        // } else if (this.iterableParts.length > iterable.length) {
        //   const nodeToRemove = this.iterableParts[iterable.length].beforeNode.nextSibling;
        //   moveNodes(this.parentNode, nodeToRemove, this.afterNode);
        //   this.iterableParts.length = iterable.length;
        // }

        var index = 0;
        var before = this.afterNode ? this.afterNode.previousSibling : this.parentNode.lastChild;
        var after = void 0;
        var parent = this.parentNode;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var value = _step.value;

            var part = this.iterableParts[index];
            if (part === undefined) {
              after = document.createTextNode('');
              this.parentNode.insertBefore(after, this.afterNode);
              part = new NodePart({ before: before, after: after, parent: parent });
              this.iterableParts.push(part);
              before = after;
            }
            part.render(value);
            index++;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (index === 0) {
          moveNodes(this.parentNode, this.beforeNode, this.afterNode);
        } else if (index < this.iterableParts.length) {
          var lastPart = this.iterableParts[index - 1];
          moveNodes(this.parentNode, lastPart.afterNode, this.afterNode);
        }
        this.iterableParts.length = index;
      }

      /**
       * Render a DOM node in this part
       */

    }, {
      key: '_renderNode',
      value: function _renderNode(node) {
        // If we are not already rendering this node
        if (this.node !== node) {
          this.clear();
          this.parentNode.insertBefore(node, this.afterNode);
          this.node = node;
        }
      }

      /**
       * Render the result of a promise in this part
       */

    }, {
      key: '_renderPromise',
      value: function _renderPromise(promise) {
        var _this = this;

        // If the promise is not the last value or promise
        if (this.value !== promise && this.promise !== promise) {
          this.clear();
          this.promise = promise;
          this.value = promise;
          // When the promise resolves, render the result of that promise
          promise.then(function (value) {
            // Render the promise result only if the last rendered value was the promise
            if (_this.value === promise) {
              _this.render(value);
            }
          });
        }
      }

      /**
       * Clear out the content of this NodePart
       *
       * If the current content is part of a DocumentFragment (it is the result of a TemplateResult or an Array)
       * The current content is moved back into that fragment to be used again if the same fragment is rendered
       * Otherwise, the current content is removed from the DOM permanently
       */

    }, {
      key: 'clear',
      value: function clear() {
        moveNodes(this.parentNode, this.beforeNode, this.afterNode, this.node);
        this.node = emptyNode;
      }
    }]);
    return NodePart;
  }();

  var moveNodes = function moveNodes(parent, before, after, target) {
    var nodeToRemove = void 0;
    if (before == undefined) {
      nodeToRemove = parent.firstChild;
    } else {
      nodeToRemove = before && before.nextSibling;
    }
    if (nodeToRemove !== null) {
      nodeToRemove = nodeToRemove || parent.firstChild;
      var remove = void 0;
      var nextNode = void 0;
      if (target instanceof DocumentFragment) {
        remove = function remove() {
          return target.appendChild(nodeToRemove);
        };
      } else {
        remove = function remove() {
          return parent.removeChild(nodeToRemove);
        };
      }

      while (nodeToRemove != after) {
        nextNode = nodeToRemove.nextSibling;
        remove();
        nodeToRemove = nextNode;
      }
    }
  };

  // The node in the CommentPart constructor must be a CommentNode
  var CommentPart = function () {
    function CommentPart(_ref2) {
      var node = _ref2.node;
      classCallCheck(this, CommentPart);

      this.node = node;
    }

    createClass(CommentPart, [{
      key: 'render',
      value: function render(value) {
        this.node.textContent = value;
      }
    }]);
    return CommentPart;
  }();

  var AttributePart = function () {
    function AttributePart(_ref3) {
      var node = _ref3.node,
          attribute = _ref3.attribute;
      classCallCheck(this, AttributePart);

      this.node = node;
      switch (attribute[0]) {
        case '.':
          this.render = this._renderProperty;
        case '?':
          this.render = this.render || this._renderBoolean;
        case '@':
          this.render = this.render || this._renderEvent;
          this.node.removeAttribute(attribute);
          this.name = attribute.slice(1);
          break;
        default:
          this.render = this._renderAttribute;
          this.name = attribute;
      }
    }

    createClass(AttributePart, [{
      key: '_renderProperty',
      value: function _renderProperty(value) {
        this.node[this.name] = value;
      }
    }, {
      key: '_renderBoolean',
      value: function _renderBoolean(boolean) {
        if (this.value !== !!boolean) {
          boolean ? this.node.setAttribute(this.name, '') : this.node.removeAttribute(this.name);
          this.value = boolean;
        }
      }
    }, {
      key: '_renderEvent',
      value: function _renderEvent(listener) {
        if (this.value !== listener) {
          this.node.removeEventListener(this.name, this.value);
          this.node.addEventListener(this.name, listener);
          this.value = listener;
        }
      }
    }, {
      key: '_renderAttribute',
      value: function _renderAttribute(string) {
        if (string !== this.value) {
          this.node.setAttribute(this.name, string);
          this.value = string;
        }
      }
    }]);
    return AttributePart;
  }();

  var lastAttributeNameRegex = /[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=$/;
  var filter = [].filter;

  var findParts = function findParts(strings, template) {
    var parts = [];

    // Recursive depth-first tree traversal that finds nodes in the subtree of `node` that are parts
    // The path is an array of incides of childNodes to get to this node
    var recursiveSearch = function recursiveSearch(node, path) {
      // If the node is a CommentNode, check if it is a marker for a CommentPart or NodePart
      if (node.nodeType === 8) {
        if (node.nodeValue === commentMarker) {
          parts.push({ type: CommentPart, path: path });
        } else if (node.nodeValue === nodeMarker) {
          parts.push({ type: NodePart, path: path });
        }
        // If it is not a marker for a Part, it is a regular comment
      } else {
        // If the node is an ElementNode, it may contain AttributeParts
        if (node.nodeType === 1) {
          // If the node has the failMarker, the context was incorrectly recognised as a Node context
          // This happens when an attribute literal contains the '>' character
          // There is no way to fix this, so throw an error to alert the developer to fix it
          if (node.hasAttribute(failMarker)) {
            throw new Error("The '>' character is not allowed in attribute literals. Replace with '&gt;'");
          }
          // If the node has any AttributeParts, it will have the attributeMarker attribute set
          if (node.hasAttribute(attributeMarker)) {
            node.removeAttribute(attributeMarker);

            // Find the number of dynamic attributes by checking all attribute values against the attributeMarker
            var dynamicAttributes = filter.call(node.attributes, function (attribute) {
              return attribute.value === attributeMarker;
            }).length;

            // If the node has the 'style' attribute, test against IEStyleMarker to check if the attribute is dynamic
            if (node.getAttribute('style') === IEStyleMarker) {
              dynamicAttributes += 1;
            }

            for (var i = 0; i < dynamicAttributes; i++) {
              // Find the name of this AttributePart using the lastAttributeNameRegex on the string before this part
              var attribute = lastAttributeNameRegex.exec(strings[parts.length])[1];
              parts.push({ type: AttributePart, path: path, attribute: attribute });
            }
          }
        }

        // Recursively search all children of this node
        var children = node.childNodes;
        var length = children.length;
        for (var _i = 0; _i < length; _i++) {
          recursiveSearch(children[_i], path.concat([_i]));
        }
      }
    };

    // Recursively search the content of the template for parts
    recursiveSearch(template.content, []);

    // If we found less parts than we should, something went wrong
    // Most likely a double attribute assignment was dropped by the HTML parser
    // Throw an error and warn the developer
    if (parts.length < strings.length - 1) {
      throw new Error("Double attribute assignments are not allowed: '<div a=${0} a=${0}>'");
    }
    return parts;
  };

  // The second marker is to add a boolean attribute to the element
  // This is to easily test if a node has dynamic attributes by checking against that attribute
  var attributeMarkerTag = attributeMarker + ' ' + attributeMarker;

  // The space at the end is necessary, to avoid accidentally closing comments with `<!-->`
  var commentMarkerTag = '--><!--' + commentMarker + '--><!-- ';

  // The extra content at the end is to add a flag to an element when
  // a nodeMarkerTag is inserted as an attribute due to an attribute containing `>`
  var nodeMarkerTag = '<!--' + nodeMarker + '-->';

  var attributeContext = Symbol('attributeContext');
  var commentContext = Symbol('commentContext');
  var nodeContext = Symbol('nodeContext');
  var unchangedContext = Symbol('unchangedContext');

  var contextMap = new Map();
  contextMap.set(attributeContext, attributeMarkerTag);
  contextMap.set(commentContext, commentMarkerTag);
  contextMap.set(nodeContext, nodeMarkerTag);

  var parseContext = function parseContext(string) {
    var openComment = string.lastIndexOf('<!--');
    var closeComment = string.indexOf('-->', openComment + 1);
    var commentClosed = closeComment > -1;
    var type = void 0;
    if (openComment > -1 && !commentClosed) {
      type = commentContext;
    } else {
      var closeTag = string.lastIndexOf('>');
      var openTag = string.indexOf('<', closeTag + 1);
      if (openTag > -1) {
        type = attributeContext;
      } else {
        if (closeTag > -1) {
          type = nodeContext;
        } else {
          type = unchangedContext;
        }
      }
    }
    return { commentClosed: commentClosed, type: type };
  };

  var parseTemplate = function parseTemplate(strings) {
    var html = [];
    var lastStringIndex = strings.length - 1;
    var currentContext = nodeContext;
    for (var i = 0; i < lastStringIndex; i++) {
      var string = strings[i];
      var context = parseContext(string);
      if ((currentContext !== commentContext || context.commentClosed) && context.type !== unchangedContext) {
        currentContext = context.type;
      }
      if (currentContext === attributeContext && string.slice(-1) !== '=') {
        throw new Error('Only bare attribute parts are allowed: `<div a=${0}>`');
      }
      html.push(string);
      html.push(contextMap.get(currentContext));
    }

    html.push(strings[lastStringIndex]);
    return html.join('');
  };

  var buildTemplate = function buildTemplate(strings) {
    var template = document.createElement('template');
    template.innerHTML = parseTemplate(strings);
    return template;
  };

  /**
   * A map that contains all the template literals we have seen before
   * It maps from a String array to a Template object
   *
   * @typedef {Map.<[String], Template>}
   */
  var templateMap = new Map();

  /**
   * Template holds the DocumentFragment that is to be used as a prototype for instances of this template
   * When a template is to be rendered in a new location, a clone will be made from this
   *
   * @prop {[String]} strings
   *   The unique string array that this template represents
   * @prop {[DocumentFragment]} element
   *   The DocumentFragment that can be cloned to make instances of this template
   * @prop {[Object]} parts
   *   The descriptions of the parts in this Template. Each part has a path which defines a unique location in the
   *   template DOM tree, a type which defines the part type, and an optional attribute which defines the name of
   *   the attribute this part represents.
   */
  var Template = function Template(strings) {
    classCallCheck(this, Template);

    this.strings = strings;
    this.element = buildTemplate(strings);
    this.parts = findParts(strings, this.element);
  };

  /**
   * TemplateResult holds the strings and values that result from a tagged template string literal.
   * TemplateResult can find and return a unique Template object that represents its tagged template string literal.
   */
  var TemplateResult = function () {
    function TemplateResult(strings, values) {
      classCallCheck(this, TemplateResult);

      this.strings = strings;
      this.values = values;
      this._template = undefined;
    }

    createClass(TemplateResult, [{
      key: 'template',
      get: function get$$1() {
        if (this._template) {
          return this._template;
        }
        var template = templateMap.get(this.strings);
        if (!template) {
          template = new Template(this.strings);
          templateMap.set(this.strings, template);
        }
        this._template = template;
        return template;
      }
    }]);
    return TemplateResult;
  }();

  /**
   * An instance of a template that can be rendered somewhere
   *
   * @prop {Template} template
   *   The unique Template object that this is an instance of
   * @prop {[DocumentFragment]} fragment
   *   The DocumentFragment that is a clone of the Template's prototype DocumentFragment
   * @prop {[AttributePart|CommentPart|NodePart|]} parts
   *   The parts that render into this template instance
   */
  var TemplateInstance = function () {
    function TemplateInstance(template, parent, before, after) {
      var _this = this;

      classCallCheck(this, TemplateInstance);

      this.template = template;
      this.fragment = template.element.content.cloneNode(true);

      // Create new Parts based on the part definitions set on the Template
      var parts = this.template.parts.map(function (part) {
        var node = _this.fragment;
        part.path.forEach(function (nodeIndex) {
          node = node.childNodes[nodeIndex];
        });
        part.node = node;
        if (part.type === NodePart) {
          if (part.path.length === 1) {
            part.parent = parent;
            part.before = node.previousSibling || before;
            part.after = node.nextSibling || after;
          } else {
            part.parent = node.parentNode;
          }
        }
        return part;
      });
      this.parts = parts.map(function (part) {
        return new part.type(part);
      });
    }

    /**
     * Render values into the parts of this TemplateInstance
     *
     * @param {[any]} values
     *   An array of values to render into the parts. There should be one value per part
     */

    createClass(TemplateInstance, [{
      key: 'render',
      value: function render(values) {
        this.parts.map(function (part, index) {
          return part.render(values[index]);
        });
      }
    }]);
    return TemplateInstance;
  }();

  /**
   * Tagging function to tag JavaScript template string literals as HTML
   *
   * @return {TemplateResult}
   *   The strings and values of the template string wrapped in a TemplateResult object
   */
  var html = function html(strings) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return new TemplateResult(strings, values);
  };

  /**
   * Render content into a target node
   *
   * @param {any} content
   *   Any content you wish to render. Usually a template string literal tagged with the `html` function
   * @param {Node} target
   *   An HTML Node that you wish to render the content into.
   *   The content will become the sole content of the target node.
   */
  var render = function render(content, target) {
    // Check if the target has a NodePart that represents its content
    var part = target.__nodePart;
    if (!part) {
      // If it does not, create a new NodePart
      part = new NodePart({ parent: target });
      target.__nodePart = part;
    }
    // Task the NodePart of this target to render the content
    part.render(content);
  };

  exports.html = html;
  exports.render = render;
  exports.noChange = noChange;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=lite-html.es5.js.map
